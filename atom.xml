<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小志的博客</title>
  
  <subtitle>小志</subtitle>
  <link href="https://chinaxizozhi.chinaxiaozhi.github.io/atom.xml" rel="self"/>
  
  <link href="https://chinaxizozhi.chinaxiaozhi.github.io/"/>
  <updated>2021-07-19T08:53:06.773Z</updated>
  <id>https://chinaxizozhi.chinaxiaozhi.github.io/</id>
  
  <author>
    <name>小志</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人学习记录</title>
    <link href="https://chinaxizozhi.chinaxiaozhi.github.io/2021/07/19/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E8%BD%BD/"/>
    <id>https://chinaxizozhi.chinaxiaozhi.github.io/2021/07/19/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E8%BD%BD/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-07-19T08:53:06.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021年6月7号学习ElasticSearch-完毕"><a href="#2021年6月7号学习ElasticSearch-完毕" class="headerlink" title="2021年6月7号学习ElasticSearch(完毕)"></a>2021年6月7号学习<code>ElasticSearch</code>(完毕)</h2><ul><li>计划学习 <code>JAVASE</code>网络编程</li></ul><h2 id="2021年6月15号学习短信验证码-完毕"><a href="#2021年6月15号学习短信验证码-完毕" class="headerlink" title="2021年6月15号学习短信验证码(完毕)"></a>2021年6月15号学习短信验证码(完毕)</h2><ul><li>用户登录名称 xxxxxxxxxxxxxxxxxx<ul><li>AccessKey ID 你的 AccessKey ID</li><li>AccessKey Secret 你的 AccessKey Secret</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入短信业务依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.aliyun&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dysmsapi20170525&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.0</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.73</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">2.4</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            Client client = SmsApplicationTests.createClient(<span class="string">&quot;accessKeyId&quot;</span>, <span class="string">&quot;accessKeySecret&quot;</span>);</span><br><span class="line">            SendSmsRequest sendSmsRequest = <span class="keyword">new</span> SendSmsRequest();</span><br><span class="line">            Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">            sendSmsRequest.setPhoneNumbers(<span class="string">&quot;15840905655&quot;</span>);</span><br><span class="line">            <span class="comment">//短信签名</span></span><br><span class="line">            sendSmsRequest.setSignName(<span class="string">&quot;小志学习Java&quot;</span>);</span><br><span class="line">            <span class="comment">//短信模板code</span></span><br><span class="line">            sendSmsRequest.setTemplateCode(<span class="string">&quot;SMS_218174229&quot;</span>);</span><br><span class="line">            <span class="comment">//模板参数为json格式的字符</span></span><br><span class="line">            map.put(<span class="string">&quot;code&quot;</span>,<span class="number">2345</span>);</span><br><span class="line">            sendSmsRequest.setTemplateParam(JSONObject.toJSONString(map));</span><br><span class="line">            <span class="comment">// 复制代码运行请自行打印 API 的返回值</span></span><br><span class="line">            client.sendSms(sendSmsRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用AK&amp;SK初始化账号Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accessKeyId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accessKeySecret</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.aliyun.dysmsapi20170525.<span class="function">Client <span class="title">createClient</span><span class="params">(String accessKeyId, String accessKeySecret)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config()</span><br><span class="line">                <span class="comment">// 您的AccessKey ID</span></span><br><span class="line">                .setAccessKeyId(<span class="string">&quot;xxxxxxxxxxxx&quot;</span>)</span><br><span class="line">                <span class="comment">// 您的AccessKey Secret</span></span><br><span class="line">                .setAccessKeySecret(<span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="comment">// 访问的域名</span></span><br><span class="line">        config.endpoint = <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> com.aliyun.dysmsapi20170525.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2021年6月18号学习redis-完毕"><a href="#2021年6月18号学习redis-完毕" class="headerlink" title="2021年6月18号学习redis(完毕)"></a>2021年6月18号学习<code>redis</code>(完毕)</h2><ul><li><p>数据结构 : </p><ul><li><p><code>set</code></p><ul><li><code>sadd key 值</code> 添加</li><li><code>smembers key</code> 查看</li><li><code>srandmember key</code> 随机选出一个元素</li><li><code>spop key</code> 随机删除<code>set</code>集合中的元素</li><li><code>smove key1 key2 值</code> 将一个值移动到另一个集合中</li><li><code>sdiff key1 key2</code> 差极</li><li><code>sinter key1 key2</code> 交集</li><li><code>sunion key1 key2</code> 并集</li></ul></li><li><p><code>Hash</code>(哈希)</p><ul><li><p>```bash<br>127.0.0.1:6379&gt; hset myhash field1 xiaozhi<br>(integer) 1<br>127.0.0.1:6379&gt; hget myhash field1<br>“xiaozhi”<br>127.0.0.1:6379&gt; hmset myhas field1 hello field2 world<br>OK<br>127.0.0.1:6379&gt; hmget myhas field1 field2</p><ol><li>“hello”</li><li>“world”</li></ol><p>127.0.0.1:6379&gt; HGETALL myhash</p><ol><li>“field1”</li><li>“xiaozhi”</li></ol><p>127.0.0.1:6379&gt; hgetall myhash</p><ol><li>“field1”</li><li>“xiaozhi”</li></ol><p>127.0.0.1:6379&gt;<br>127.0.0.1:6379&gt; HDEL myhas field1 # 删除<br>(integer) 1<br>########################################################################<br>127.0.0.1:6379&gt; HDEL myhas field1  # 获取hash长度<br>(integer) 1<br>hkeys myhas # 获取所有的key<br>hvals myhas # 获取所有的vaklu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```bash</span><br><span class="line">  #  geospatial </span><br><span class="line">  127.0.0.1:6379&gt; GEOADD china:city 116.40 39.90 beijing </span><br><span class="line">  (integer) 1</span><br><span class="line">  127.0.0.1:6379&gt; GEOADD china:city 121.47 31.23 shanghai</span><br><span class="line">  (integer) 1</span><br><span class="line">  127.0.0.1:6379&gt; GEOADD china:city 106.50 29.53 chognqing</span><br><span class="line">  (integer) 1</span><br><span class="line">  127.0.0.1:6379&gt; </span><br><span class="line">  </span><br><span class="line">  ## 获取经度和纬度</span><br><span class="line">  127.0.0.1:6379&gt; GEOPOS china:city beijing</span><br><span class="line">  1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">     2) &quot;39.90000009167092543&quot;</span><br><span class="line">  127.0.0.1:6379&gt; GEOPOS china:city beijing chongqing</span><br><span class="line">  1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">     2) &quot;39.90000009167092543&quot;</span><br><span class="line">  2) (nil)</span><br><span class="line">  127.0.0.1:6379&gt; GEOPOS china:city beijing chognqing</span><br><span class="line">  1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">     2) &quot;39.90000009167092543&quot;</span><br><span class="line">  2) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">     2) &quot;29.52999957900659211&quot;</span><br><span class="line">  127.0.0.1:6379&gt; </span><br><span class="line">  </span><br><span class="line">  ## 查看城市之间的距离</span><br><span class="line">  127.0.0.1:6379&gt; GEODIST china:city beijing shanghai</span><br><span class="line">  &quot;1067378.7564&quot;</span><br><span class="line">  127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km</span><br><span class="line">  &quot;1067.3788&quot;</span><br><span class="line">  127.0.0.1:6379&gt; GEODIST china:city beijing chognqing km</span><br><span class="line">  &quot;1464.0708&quot;</span><br><span class="line">  </span><br><span class="line">  ## 查看附近的额人  所有的城市都录入 才会让结果准确</span><br><span class="line">  127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km</span><br><span class="line">  1) &quot;chognqing&quot;</span><br><span class="line">  127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km withcoord</span><br><span class="line">  1) 1) &quot;chognqing&quot;</span><br><span class="line">     2) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">        2) &quot;29.52999957900659211&quot;</span><br><span class="line">  127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km withcoord count 1</span><br><span class="line">  1) 1) &quot;chognqing&quot;</span><br><span class="line">     2) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">        2) &quot;29.52999957900659211&quot;</span><br><span class="line">    </span><br><span class="line">  # 找出位于制定元素周围的其他元素</span><br><span class="line">  127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km</span><br><span class="line">  1) &quot;beijing&quot;</span><br><span class="line">  </span><br><span class="line">  # 两个城市返回的一维字符串</span><br><span class="line">  127.0.0.1:6379&gt; GEOHASH china:city beijing chognqing</span><br><span class="line">  1) &quot;wx4fbxxfke0&quot;</span><br><span class="line">  2) &quot;wm5xzrybty0&quot;</span><br><span class="line">  </span><br><span class="line">  # 底层就是zset</span><br><span class="line">  127.0.0.1:6379&gt; ZRANGE china:city 0 -1</span><br><span class="line">  1) &quot;chognqing&quot;</span><br><span class="line">  2) &quot;shanghai&quot;</span><br><span class="line">  3) &quot;beijing&quot;</span><br><span class="line">  127.0.0.1:6379&gt; zrem china:city beijing</span><br><span class="line">  (integer) 1</span><br><span class="line">  127.0.0.1:6379&gt; ZRANGE china:city 0 -1</span><br><span class="line">  1) &quot;chognqing&quot;</span><br><span class="line">  2) &quot;shanghai&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>```bash<br>pfcount key1  key2 key3   # 新创建的key1  统计 key2 key3</p><h1 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```b`ash</span><br><span class="line">  # 事务</span><br></pre></td></tr></table></figure><p>127.0.0.1:6379&gt; MULTI<br>OK<br>127.0.0.1:6379(TX)&gt; set k1 1<br>QUEUED<br>127.0.0.1:6379(TX)&gt; set k2 2<br>QUEUED<br>127.0.0.1:6379(TX)&gt; EXEC</p><ol><li>OK</li><li>OK</li></ol><p>127.0.</p></li></ul></li></ul></li></ul><p>0.1:6379&gt; </p><pre><code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">&gt;# `redis.config` </span><br><span class="line"></span><br><span class="line">* 阅读配置文件</span><br><span class="line"></span><br><span class="line">&gt;# `Redis`持久化</span><br><span class="line"></span><br><span class="line">* ## `RDB`</span><br><span class="line"></span><br><span class="line">  * 在主从复制中`rdb`是用来备用的</span><br><span class="line"></span><br><span class="line">  * `Redis` 是一种内存数据库，将数据保存在内存中，读写效率要比传统的将数据保存在磁盘上的数据库要快很多。但是一旦进程退出，`Redis` 的数据就会丢失。</span><br><span class="line"></span><br><span class="line">  * ==rdb保存的文件是dump.rdb==</span><br><span class="line"></span><br><span class="line">  * 查看进程</span><br><span class="line"></span><br><span class="line">    * ``` bash</span><br><span class="line">      ps -ef|grep redis</span><br></pre></td></tr></table></figure>&gt; 触发机制* `save`的规则满足情况下,会触发`rdb`规则* 执行`flushall`操作时触发* 退出时也会触发&gt; 如何恢复`rdb`文件* 只需将`reb`文件放到我们的`redis`启动目录下就可以,`redis`启动的时候回自动检查`dump.rdb`将其恢复其中的数据* ```bash  config get dir  &quot;dir&quot;  &quot;/usr/locale/bin&quot;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * 优点 : </span><br><span class="line"></span><br><span class="line">      * 适合大规模数据恢复 ! `dump.rdb`</span><br><span class="line">      * 如果你对数据完整新要求不高</span><br><span class="line"></span><br><span class="line">    * 缺点 :</span><br><span class="line"></span><br><span class="line">      * 需要一定的时间间隔去操作 ! 如果`redis`意外宕机了,最后一次修改就没有了 ! </span><br><span class="line">      * `fork`进程的时候,会占用一定的空间</span><br><span class="line"></span><br><span class="line">* ## `AOF(Append Only Fiel)`</span><br><span class="line"></span><br><span class="line">  * 将我们的所有命令都记录下来,`history`恢复的时候就把这个文件全部执行一遍</span><br><span class="line">  * 默认是不开启的,我们需要手动进行配置</span><br><span class="line">  * 重启`redis`就可以生效了</span><br><span class="line">  * 如果`aof`配置文件有错误,`redis`启动不起来的,需要修复配置文件`redis`给我们提供了一个工具`redis-chek-aof` </span><br><span class="line">  * 优点 :</span><br><span class="line">    * 每一次修改都同步,文件的完整新会更好</span><br><span class="line">    * 默认开启是每秒同步一次,可能会丢失一秒数据</span><br><span class="line">    * 从不同步,效率更高</span><br><span class="line">  * 缺点 : </span><br><span class="line">    * 相对于数据文件来说,`aof`远远大于`rdb`,修复速度也比`rdb`慢</span><br><span class="line"></span><br><span class="line">&gt;#  `Redis`发布订阅</span><br><span class="line"></span><br><span class="line">&gt; # 主从复制</span><br><span class="line"></span><br><span class="line">&gt; ## 哨兵模式(自动版选取老大)</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 如果有多集群需要配置 多端口</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mymaster 192.168.247.128 6379 1</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 900000</span><br><span class="line">sentinel parallel-syncs mymaster 2</span><br></pre></td></tr></table></figure></code></pre><blockquote><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a><code>Redis</code>缓存穿透和雪崩</h1></blockquote><h1 id="springSecurity-学习-2021-6-24-完毕"><a href="#springSecurity-学习-2021-6-24-完毕" class="headerlink" title="springSecurity   学习(2021.6.24 完毕)"></a><code>springSecurity </code>  学习(2021.6.24 完毕)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2021年6月7号学习ElasticSearch-完毕&quot;&gt;&lt;a href=&quot;#2021年6月7号学习ElasticSearch-完毕&quot; class=&quot;headerlink&quot; title=&quot;2021年6月7号学习ElasticSearch(完毕)&quot;&gt;&lt;/a&gt;2021</summary>
      
    
    
    
    <category term="JAVA" scheme="https://chinaxizozhi.chinaxiaozhi.github.io/category/JAVA/"/>
    
    
    <category term="短信服务" scheme="https://chinaxizozhi.chinaxiaozhi.github.io/tag/%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>git从入门到精通</title>
    <link href="https://chinaxizozhi.chinaxiaozhi.github.io/2021/07/19/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>https://chinaxizozhi.chinaxiaozhi.github.io/2021/07/19/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2021-07-20T05:33:32.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git入门到高级教程"><a href="#Git入门到高级教程" class="headerlink" title="Git入门到高级教程"></a>Git入门到高级教程</h1><h2 id="为什么要进行项目文件的版本管理"><a href="#为什么要进行项目文件的版本管理" class="headerlink" title="为什么要进行项目文件的版本管理"></a>为什么要进行项目文件的版本管理</h2><ol><li>代码备份和恢复</li><li>团队开发和协作流程</li><li>项目分支管理和备份</li></ol><h2 id="git-是什么？"><a href="#git-是什么？" class="headerlink" title="git 是什么？"></a>git 是什么？</h2><p>git是一个分布式的版本控制软件。版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>最初由林納斯·托瓦茲創作，於2005年以GPL釋出。最初目的是為更好地管理Linux內核開發而設計。</p><blockquote><p>2005年，安德鲁·垂鸠写了一个简单程序，可以连接BitKeeper的存储库，BitKeeper著作权拥有者拉里·麦沃伊认为安德鲁·垂鸠对BitKeeper内部使用的协议进行逆向工程，决定收回无偿使用BitKeeper的许可。Linux内核开发团队与BitMover公司进行磋商，但无法解决他们之间的歧见。林纳斯·托瓦兹决定自行开发版本控制系统替代BitKeeper，以十天的时间，编写出第一个git版本.</p></blockquote><h2 id="集中式和分布式版本控制软件"><a href="#集中式和分布式版本控制软件" class="headerlink" title="集中式和分布式版本控制软件"></a>集中式和分布式版本控制软件</h2><h3 id="集中式版本控制软件"><a href="#集中式版本控制软件" class="headerlink" title="集中式版本控制软件"></a>集中式版本控制软件</h3><p>集中化的版本控制系统（<code>Centralized Version Control Systems</code>，简称 <code>CVCS</code>）应运而生。 这类系统，诸如 <code>CVS</code>、<code>Subversion</code> 以及 <code>Perforce</code> 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><p>集中式管理的缺点：</p><ol><li>中央服务器的单点故障，导致整个版本管理瘫痪</li><li>中央服务器故障导致所有的版本丢失</li><li>当客户端和服务器端无法进行网络连接的时，客户端无法进行提交代码和保存版本，也不能恢复某个版本</li></ol><p><img src="../images/centralized.png" alt="集中式"></p><h3 id="分布式版本控制软件"><a href="#分布式版本控制软件" class="headerlink" title="分布式版本控制软件"></a>分布式版本控制软件</h3><p>分布式版本控制系统（<code>Distributed Version Control System</code>，简称 <code>DVCS</code>）.分布式就是每个人都有一份完整的仓库版本，提交和管理都是在本地进行，当然也可以进行远程的仓库之间进行合并提交等操作。</p><p><img src="../images/distributed.png" alt="分布式"></p><h2 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h2><h3 id="Linux-上安装"><a href="#Linux-上安装" class="headerlink" title="Linux 上安装"></a>Linux 上安装</h3><p>如果你想在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果 以 Fedora 上为例，你可以使用 yum:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><p>如果你在基于 Debian 的发行版上，请尝试用 apt-get:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="http://git-scm.com/download/linux">http://git-scm.com/download/linux</a>。</p><h3 id="在-Mac-上安装"><a href="#在-Mac-上安装" class="headerlink" title="在 Mac 上安装"></a>在 Mac 上安装</h3><p>方法一：</p><p>最简单的方法是安装 <code>Xcode Command Line Tools</code>,然后在 Terminal 里尝试首次运行 git 命令即可。 如果没有安装过命令行开发者工具，将会提示 你安装。</p><p>方法二：（推荐）</p><p>使用 <a href="https://github.com/mxcl/homebrew">homebrew</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure><h3 id="windows上安装"><a href="#windows上安装" class="headerlink" title="windows上安装"></a>windows上安装</h3><p>直接下载安装包：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p><h3 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h3><p>windows请从开始菜单程序中打开<code>gitbash</code>,其他系统请打开终端工具或者shell命令行工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出，仅供参考</span></span><br><span class="line">git version 2.18.0</span><br></pre></td></tr></table></figure><h2 id="git-快速上手和配置"><a href="#git-快速上手和配置" class="headerlink" title="git 快速上手和配置"></a>git 快速上手和配置</h2><h3 id="用户名和邮箱配置"><a href="#用户名和邮箱配置" class="headerlink" title="用户名和邮箱配置"></a>用户名和邮箱配置</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会 使用这些信息，并且它会写入到你的每一次提交中。</p><p>windows请从开始菜单程序中打开<code>gitbash</code>,其他系统请打开终端工具或者shell命令行工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;aicoder&quot;</span></span><br><span class="line">$ git config --global user.email laoma@aicoder.com</span><br></pre></td></tr></table></figure><p><strong>请把用户名和邮箱换成你自己的</strong></p><blockquote><p>如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事 情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运 行没有 –global 选项的命令来配置。</p></blockquote><p>以上配置完成后，检测是否配置成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出以下内容，仅供参考</span></span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=aicoder</span><br><span class="line">user.email=laoma@aicoder.com</span><br><span class="line">color.status=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p><code>Git</code> 服务器大部分都使用 <code>SSH</code> 公钥进行认证,其他认证方式都不方便，创建<code>SSH</code>公钥的方法。</p><p><strong>请打开用gitbash或者终端工具运行以下命令</strong></p><p>默认情况下，用户的 <code>SSH</code> 密钥存储在其 <code>~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快 速确认自己是否已拥有密钥:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>cd命令可以帮助我们进入系统的某个目录。 ls命令可以列出当前目录下面的所有文件和文件夹的信息。</p></blockquote><p>如果已经存在<code>id_dsa</code>、<code>id_dsa.pub</code>，说明就已经生成果，后面的步骤可以省略。</p><blockquote><p>id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另 一个则是私钥。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一路回车回车即可，以下为输出内容，仅供参考</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">/root/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:xFntIEM+aKyuc5dJmCvq1xnccqCaMAcK3kBClYXc/J0 root@localhost.localdomain</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|..o.*. .. ..     |</span></span><br><span class="line"><span class="string">|.. + + +oo. .    |</span></span><br><span class="line"><span class="string">|o     = Bo.o     |</span></span><br><span class="line"><span class="string">|o.   + o E  .    |</span></span><br><span class="line"><span class="string">|+.o +oo S        |</span></span><br><span class="line"><span class="string">|+..+o+.o         |</span></span><br><span class="line"><span class="string">|.oo oo=o         |</span></span><br><span class="line"><span class="string">| ooooo+          |</span></span><br><span class="line"><span class="string">|ooo+ .           |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>首先 ssh-keygen 会确认密钥的存储位置(默认是 .ssh/id_rsa)，然后它会要求你输入两次密钥口令。如 果你不想在使用密钥时输入口令，将其留空即可。</p><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><h3 id="在现有目录中初始化仓库"><a href="#在现有目录中初始化仓库" class="headerlink" title="在现有目录中初始化仓库"></a>在现有目录中初始化仓库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/init</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>此时在目录中将创建一个名为 <code>.git</code> 的子目录,这里面存放当前仓库的所有的跟踪的信息。</p><p>此时当前文件夹下面的所有的文件都没有被跟踪，如果需要跟踪变化，必须添加到跟踪的参考中。</p><h3 id="添加文件和提交信息"><a href="#添加文件和提交信息" class="headerlink" title="添加文件和提交信息"></a>添加文件和提交信息</h3><p><code>git add 文件</code> 命令可以帮祝我们让git帮忙跟踪具体的文件。然后执行<code>git commit</code>提交信息，相当于确认跟踪。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add ./*.js</span><br><span class="line">$ git add a.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>提交记录的时候必须添加消息，而且添加的消息还有一定的规范，每个公司的提交消息规范不一样，视情况而定。</p></blockquote><p>参考：<a href="https://juejin.im/entry/5b429be75188251ac85830ff">你可能会忽略的 Git 提交规范</a></p><p><img src="../images/gitadd.png" alt="工作目录和暂存区"></p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><ul><li>工作区（Working Directory）</li></ul><p>工作区，也称为工作目录，也就是要进行版本管理的文件夹。</p><ul><li>暂存区（Stage或者Index）</li></ul><p>暂时存放将要记录修改版本的文件的区域。</p><p><img src="../images/0.jpeg" alt="工作目录和暂存区"></p><p>工作目录下的每一个文件都不外乎这两种状态:已跟踪或未跟踪。</p><p><code>git add</code>可以把文件加入暂存区。<br><code>git commit</code>命令可以把暂存区的文件更新变化记录到版本库中永久保存。</p><p>不在暂存区的文件，不会被追踪。</p><p><img src="../images/zc.png" alt="文件修改的流程"></p><blockquote><p>暂存区和版本库存放在 .git目录中。</p></blockquote><h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>要查看哪些文件处于什么状态，可以用 git status 命令。 如果在克隆仓库后立即使用此命令，会看到类似这 样的输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>以下是没有任何修改和暂存的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>以下是有修改未提交，有新增加为加入暂存区的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   docs/pages/vip_3git.md</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        docs/images/0.jpeg</span><br><span class="line">        docs/images/zc.png</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a><strong>状态简览</strong></h3><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code>命令，你将得到一种更为紧凑的格式输出。运行<code>git status -s</code>，状态报告输出如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><h3 id="查看文件的日志"><a href="#查看文件的日志" class="headerlink" title="查看文件的日志"></a>查看文件的日志</h3><p><code>git log</code>命令帮助我们输出git的所有操作日志。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line">    changed the version number</span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line">    removed unnecessary <span class="built_in">test</span></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><blockquote><p>按q键可以退出查看日志，回车键查看更多。</p></blockquote><ul><li>查看修改的差异</li></ul><p><code>git log -p</code></p><ul><li>查看最近两次的差异</li></ul><p><code>git log -p -2</code></p><ul><li>查看每次提交的总结</li></ul><p>正如你所看到的，<code>--stat</code> 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过 的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p><p><code>git log --stat</code></p><ul><li>在一行内显示日志</li></ul><p><code>git log --oneline</code></p><ul><li>图形化输出</li></ul><p><code>git log --graph</code></p><p>其他参数</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-p</td><td>按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–stat</td><td>显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td>只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td>仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td>显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td>使用较短的相对时间显示(比如，“2 weeks ago”)。</td></tr><tr><td>–graph</td><td>显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format(后跟指定格式)</td></tr></tbody></table><ul><li>终极必杀技，找到被reset掉的提交</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --reflog</span><br></pre></td></tr></table></figure><h3 id="取消新添加文件的暂存状态"><a href="#取消新添加文件的暂存状态" class="headerlink" title="取消新添加文件的暂存状态"></a>取消新添加文件的暂存状态</h3><p>如果你不小心添加了一个文件，但本不想让它进行跟踪管理，仅仅是临时使用，那么怎样才能从暂存区取消呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /path/to</span><br><span class="line"><span class="comment"># 添加一个文件</span></span><br><span class="line">$ touch a.txt</span><br><span class="line"><span class="comment"># 添加到暂存区</span></span><br><span class="line">$ git add a.txt</span><br></pre></td></tr></table></figure><p>此时查看git的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># 查看当前文件，在暂存区等待提交。</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">  new file:   a.txt</span><br></pre></td></tr></table></figure><p>取消暂存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD a.txt</span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 可以看到a.txt是未跟踪状态了。</span></span><br></pre></td></tr></table></figure><h3 id="取消已经跟踪文件的暂存状态"><a href="#取消已经跟踪文件的暂存状态" class="headerlink" title="取消已经跟踪文件的暂存状态"></a>取消已经跟踪文件的暂存状态</h3><p>如果一个文件已经被跟踪过了，而且已经修改后被add到了暂存区现在想取消修改暂存状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD a.txt</span><br><span class="line">$ git checkout -- a.txt</span><br></pre></td></tr></table></figure><blockquote><p>git checkout – [file]是一个危险的命令。你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。</p></blockquote><p>全部回滚</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><p><strong><code>--hard</code> 会让工作目录也会回滚到未修改之前的状态。</strong></p><h3 id="回滚到上一个提交点"><a href="#回滚到上一个提交点" class="headerlink" title="回滚到上一个提交点"></a>回滚到上一个提交点</h3><p>回滚到上一次提交，并且添加一次新的提交，提交信息不变。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后HEAD指针回滚到上一次提交</span></span><br><span class="line">$ git reset --soft HEAD^</span><br><span class="line">$ git commit -a -m <span class="string">&#x27;new commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><blockquote><p>上一次提交：HEAD^, 上两次： HEAD<del>2  上三次： HEAD</del>3 …    最好不要这么用！！！</p></blockquote><h3 id="回滚文件"><a href="#回滚文件" class="headerlink" title="回滚文件"></a>回滚文件</h3><p>让某个文件回滚到某个版本的状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- filepath</span><br></pre></td></tr></table></figure><p><img src="../images/reset.png" alt="操作路线"><br><img src="../images/git3.png" alt="git回滚原理"></p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文 件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。</p><p>我们再看一个 .gitignore 文件的例子: ‘</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># but do track lib.a, even though you&#x27;re ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>一般此文件会放到工作目录的根目录下，此文件中匹配的所有文件都会被git所有的命令忽略。</p><h2 id="git-清理"><a href="#git-清理" class="headerlink" title="git 清理"></a>git 清理</h2><p><code>git clean</code>命令用来从你的工作目录中删除所有没有tracked过的文件。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>git clean -n</code></td><td>告诉你哪些文件会被删除. 记住他不会真正的删除文件, 只是一个提醒。</td></tr><tr><td><code>git clean -d</code></td><td>删除未跟踪的目录</td></tr><tr><td><code>git clean -f</code></td><td>删除当前目录下所有没有track过的文件。忽略文件不被删除！</td></tr><tr><td><code>git clean -df</code></td><td>-d代表删除目录，-f强制删除。</td></tr><tr><td><code>git clean -xf</code></td><td>删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件</td></tr><tr><td><code>git clean -X</code></td><td>删除所有被忽略的文件</td></tr></tbody></table><blockquote><p>如果被删除的子文件夹中有 .git目录，那么会被忽略掉，如果想删除必须添加-f参数。</p></blockquote><p>比如实例：让当前工作目录回滚到上一次提交的状况，新添加的文件也被删除掉。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让暂存区和工作目录把已经被跟踪的文件清理干净</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment"># 让未追踪的文件进行清理</span></span><br><span class="line">$ git clean -f</span><br></pre></td></tr></table></figure><h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><p>项目分支就是版本库的一个副本，有了分支后可以把你的工作从开发主线上分离开来， 以免影响开发主线。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>创建分支： <code>git branch  分支名字</code>命令，切换分支的命令使用 <code>git checkout 分支名字</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b创建分支，checkout是切换分支</span></span><br><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>当一个分支完成了使命的时候，一般我们会把它删除掉。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d 命令是删除的意思，delete</span></span><br><span class="line">$ git branch -d hotfix</span><br></pre></td></tr></table></figure><h3 id="查看所有的分支"><a href="#查看所有的分支" class="headerlink" title="查看所有的分支"></a>查看所有的分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -v</span><br><span class="line">  dev    eba9a31 update the a.txt by dev</span><br><span class="line">* master d47fbfb update the a.txt by master;</span><br></pre></td></tr></table></figure><p>带*的代表是当前的分支。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>合并分支就是把其他分支的代码合并到当前的分支中。git会自动将当前分支和要合并的分支找到共同的基点，然后将当前分支的所有变化和要合并分支的变化进行三方合并，并产生一个新的提交，此次提交有两个父提交。</p><p>例如操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入主分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并dev分支</span></span><br><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure><p>合并分支：</p><ul><li><p>合并分支前，<strong>确保当前分支已经提交状态</strong></p></li><li><p>快速合并： 如果两个分支之间没有分叉，要被合并的分支提交比当前分支更新，那么只是HEAD指针的移动。</p></li><li><p>冲突解决： 如果合并的两个分支有分叉，那么自动添加一个新的提交，如果有冲突需要先解决完冲突然后再提交。</p></li></ul><p>解决冲突的办法：就是移除代码中的特殊符号，留下自己想要的代码。比如：冲突文件如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssss</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">22222222</span></span><br><span class="line"><span class="string">33333333</span></span><br><span class="line"><span class="string">44444444</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">devdevdevdev</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span></span><br></pre></td></tr></table></figure><p>移除上面的 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>  和  <code>=======</code>  <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</code>然后留下自己想要的代码就完成了冲突解决，最后add和commit一下就可以了。</p><p>完整的解决冲突的流程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到主分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把dev分支的内容合并到主分支</span></span><br><span class="line">$ git merge dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果产生冲突后,先修改文件，去掉冲突的符号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后提交修改到仓库</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;合并冲突&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>合并过程中，随时都可以停止合并，只需要 git merge abort ,仓库和工作去会回到合并之前的状态。</p></blockquote><h2 id="git标签"><a href="#git标签" class="headerlink" title="git标签"></a>git标签</h2><p>Git 可以给历史中的某一个提交打上标签。 比较有代表性的是人 们会使用这个功能来标记发布结点(v1.0 等等)。</p><h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签是非常简单直观的。 只需要输入 <code>git tag</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br></pre></td></tr></table></figure><blockquote><p>这个命令以字母顺序列出标签;</p></blockquote><p>你也可以使用特定的模式查找标签,如果只对 1.8.5<br>系列感兴趣，可以运行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l <span class="string">&#x27;v1.8.5*&#x27;</span></span><br><span class="line">v1.8.5</span><br><span class="line">v1.8.5-rc0</span><br><span class="line">v1.8.5-rc1</span><br><span class="line">v1.8.5-rc2</span><br><span class="line">v1.8.5-rc3</span><br><span class="line">v1.8.5.1</span><br><span class="line">v1.8.5.2</span><br><span class="line">v1.8.5.3</span><br><span class="line">v1.8.5.4</span><br><span class="line">v1.8.5.5</span><br></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签:轻量标签(lightweight)与附注标签(annotated)。 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><ul><li>注标签</li></ul><p>在 Git 中创建一个附注标签是很简单的。 最简单的方式是当你在运行 tag 命令时指定 -a 选项:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.4 -m <span class="string">&#x27;my version 1.4&#x27;</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><blockquote><p>-m 选项指定了一条将会存储在标签中的信息。</p></blockquote><p>通过使用git show命令可以看到标签信息与对应的提交信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May 3 20:19:12 2014 -0700</span><br><span class="line">my version 1.4</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line">  changed the version number</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><ul><li>轻量标签</li></ul><p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任 何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.4-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br><span class="line">v1.4-lw</span><br><span class="line">v1.5</span><br></pre></td></tr></table></figure><h3 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h3><p>你也可以对过去的提交打标签。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.2 9fceb02</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。 如果你想要工作目录与仓库中特定 的标签版本完全一样，可以使用git checkout -b [branchname] [tagname]在特定的标签上创建一个 新分支:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b version2 v2.0.0</span><br><span class="line">Switched to a new branch <span class="string">&#x27;version2&#x27;</span></span><br></pre></td></tr></table></figure><p>当然，如果在这之后又进行了一次提交，version2 分支会因为改动向前移动了，那么 version2 分支就会和 v2.0.0 标签稍微有些不同，这时就应该当心了。</p><h2 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h2><h3 id="变基的基本操作"><a href="#变基的基本操作" class="headerlink" title="变基的基本操作"></a>变基的基本操作</h3><p>rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新 播放”一样。翻译成通俗的话： 找到参照的仓库和当前的仓库的相同的提交，然后把当前分支后续的提交挪动到参照仓库的提交的最后，形成一条线性的提交顺序。</p><p>例如：experiment分支参照master分支进行变基</p><p><img src="../images/bj1.png" alt="变基之前"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure><p><img src="../images/bj2.png" alt="变基之后"></p><blockquote><p>远程分支的pull命令的时候的–base可以直接变基合并</p></blockquote><h3 id="改变提交历史"><a href="#改变提交历史" class="headerlink" title="改变提交历史"></a>改变提交历史</h3><p>修改多个提交信息.如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息，将想要修改的最近一次提交的父 提交作为参数传递给git rebase -i命令，即HEAD<del>2^或HEAD</del>3。记住~3可能比较容易，因为你正尝试 修改最后三次提交;</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>此时会进入vi的编辑器模式，这是需要你了解一点vi的快捷键不然没法继续操作。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pick f7f3f6d changed my name a bit</span><br><span class="line">pick 310154e updated README formatting and added blame</span><br><span class="line">pick a5f4a0d added cat-file</span><br><span class="line"><span class="comment"># Rebase 710f0f8..a5f4a0d onto 710f0f8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把最上面的pick对应改成你想要的效果，比如删除某个提交信息，则把pick改成 d为删除当前提交信息，e是修改，p默认就留下</p><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><p>远程仓库是指托管在因特网或其他网络中 的你的项目的版本库。</p><h3 id="远程分支克隆"><a href="#远程分支克隆" class="headerlink" title="远程分支克隆"></a>远程分支克隆</h3><p>克隆远程仓库，就是把远程仓库拷贝一个副本下载到本地。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/malun666/aicoder_vip_doc</span><br><span class="line"><span class="comment"># 本地目录会增加一个文件，就是把远程仓库下载到本地了</span></span><br></pre></td></tr></table></figure><p>查看远程仓库的远程的关联信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/malun666/aicoder_vip_doc (fetch)</span><br><span class="line">origin  https://github.com/malun666/aicoder_vip_doc (push)</span><br></pre></td></tr></table></figure><p>origin - 这是 Git 给你克隆的仓库服务器的默认名字。origin就代表远程仓库的别名。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>语法：<code>git remote add &lt;shortname&gt; &lt;url&gt;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/gitresp</span><br><span class="line">$ git remote add aicoder https://github.com/malun666/aicoder_vip_doc</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h3 id="远程分支拉取"><a href="#远程分支拉取" class="headerlink" title="远程分支拉取"></a>远程分支拉取</h3><p>一般先建立好远程仓库的别名后，然后用fetch命令进行拉取远程仓库的内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;远程仓库别名&gt; &lt;远程分支名&gt;</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ git fetch origin dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载所有的远程分支</span></span><br><span class="line">$ git fetch --all</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p></blockquote><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为paul，可以用git remote rename这样做:</p><ul><li>修改别名</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><ul><li>删除别名</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库详情"><a href="#查看远程仓库详情" class="headerlink" title="查看远程仓库详情"></a>查看远程仓库详情</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: git@github.com:malun666/aicoder_egg.git</span><br><span class="line">  Push  URL: git@github.com:malun666/aicoder_egg.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    tracked</span><br><span class="line">    master tracked</span><br><span class="line">  Local branches configured <span class="keyword">for</span> <span class="string">&#x27;git pull&#x27;</span>:</span><br><span class="line">    dev    merges with remote dev</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local refs configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    dev    pushes to dev    (up to date)</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单:<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 origin 服务器时(再次说明，克隆时通常会自动帮你设置好那两个 名字)，那么运行这个命令就可以将你所做的备份到服务器</p><p>具体语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</p><p>注意推送之前，必须先把远程分支的最新内容拉取下来合并或者变基成为最新的内容才可以推送。</p><p>设置关联，自动推送。</p><p>第一次执行推送的时候，添加 -u参数，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line"><span class="comment"># 后续的推送，就直接使用  git push即可，已经关联无需再指定 origin和master</span></span><br></pre></td></tr></table></figure><h3 id="远程分支拉取与合并"><a href="#远程分支拉取与合并" class="headerlink" title="远程分支拉取与合并"></a>远程分支拉取与合并</h3><p>拉取之前，确保当前仓库为提交完成状态。</p><p>拉取所有的远程分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --all</span><br><span class="line">$ git branch --all</span><br><span class="line"><span class="comment"># 此时可以看到所有的远程分支和当前分支内容</span></span><br><span class="line">  aicoder</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/aicoder</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>此时remotes开头的都是远程的分支的最新的内容，可以用merge命令进行合并分支，也可以rebase变基。</p><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到aicoder分支</span></span><br><span class="line">$ git checkout aicoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并远程的aicoder分支</span></span><br><span class="line">$ git merge remotes/origin/aicoder</span><br></pre></td></tr></table></figure><p>以上操作都太麻烦，最简单的办法就是直接使用pull命令，是以上fetch命令和merge命令的合体：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取远程的aicoder分支并与当前的aicoder分支进行合并。</span></span><br><span class="line">$ git pull origin aicoder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果合并的不同分支名字：  最后需要用 远程分支名:本地分支名</span></span><br><span class="line"><span class="comment"># $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line">$ git pull origin aicoder:master</span><br></pre></td></tr></table></figure><blockquote><p>如果合并过程中有任何的冲突，需要手动修改冲突代码，最后git add  和git commit提交。</p></blockquote><h3 id="远程分支拉取与变基"><a href="#远程分支拉取与变基" class="headerlink" title="远程分支拉取与变基"></a>远程分支拉取与变基</h3><p>远程拉取和合并可以只用git pull命令，变基也是可以的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line">git pull -r origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程origin的master分支上拉取最新的结果并且让当前仓库依照远程仓库进行变基操作。</span></span><br></pre></td></tr></table></figure><p>变基过程中可以随时进行 abort停止。</p><h2 id="将已有项目添加至git"><a href="#将已有项目添加至git" class="headerlink" title="将已有项目添加至git"></a>将已有项目添加至git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init   # 把项目初始化,相当于在项目的跟目录生成一个 .git 目录</span><br><span class="line">将 .ignore 文件添加至该项目中</span><br><span class="line">git add .    # 把项目的所有文件加入暂存区</span><br><span class="line">git commit -am &#x27;项目初始化&#x27;     # 把项目提交到本地仓库，引号里面的是这次提交的注释，方便以后查看。</span><br><span class="line">git remote rm origin  # 先删除远程 Git 仓库</span><br><span class="line">git remote add origin https://github.com/BobinYang/   #为本地的仓库创建一个远程仓库. 例如：git remote add origin https://github.com/BobinYang/HtmlAgilityPackSample.git</span><br><span class="line">git pull --rebase origin master  # 把远端仓库中的代码 拉到本地进得合并一下。</span><br></pre></td></tr></table></figure><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>GitHub 是最大的 Git 版本库在线托管商，是一个免费托管开源项目的远程仓库，非开源项目收费。</p><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>直接访问 <a href="https://github.com/">https://github.com</a></p><h3 id="配置SSH-访问"><a href="#配置SSH-访问" class="headerlink" title="配置SSH 访问"></a>配置SSH 访问</h3><p>第一步：登录github<br>第二步：点击github右上角头像，弹出菜单选择setting，然后选择<code>SSH and GPG keys</code>菜单，点击 <code>New SSH Key</code>按钮.</p><p><img src="../images/github1.png" alt="设置ssh key"></p><p>第三步：找到之前生成的ssh的公钥<br>打开终端或者命令行（gitbash)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/ssdfsfsdfadfadfasdfasdfaslajfdaljADFASdfkasdflasjflasjdflajA23ljlsdjfaljf</span><br></pre></td></tr></table></figure><p>把<code>~/.ssh/id_rsa.pub</code>文件中的内容拷贝到github的秘钥框中。如下图所示：</p><p><img src="../images/github2.png" alt="设置ssh key"></p><h3 id="github-创建仓库并设置管理"><a href="#github-创建仓库并设置管理" class="headerlink" title="github 创建仓库并设置管理"></a>github 创建仓库并设置管理</h3><p>在github的网站顶部点击 加号按钮。</p><p><img src="../images/github3.png" alt="设置ssh key"></p><p>然后输入仓库的名字和仓库的描述。<br><img src="../images/github4.png" alt="设置ssh key"></p><p>好的此时远程仓库创建好了，然后就可以进行远程关联和推送和拉取工作。</p><p>例如：</p><p>在本地新建仓库并进行关联：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# gitlearn&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin git@github.com:malun666/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>在本地已有的仓库上进行关联：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:malun666/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>详情请参考： <a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md">Git工作流指南</a></p><h3 id="git集中式工作流"><a href="#git集中式工作流" class="headerlink" title="git集中式工作流"></a>git集中式工作流</h3><p>集中式工作流以中央仓库作为项目所有修改的单点实体。相比SVN缺省的开发分支trunk，Git叫做master，所有修改提交到这个分支上。</p><p><img src="../images/git-workflow-svn.png" alt="设置ssh key"></p><ul><li>所有成员都以中央仓库为基础进行clone</li><li>所有成员代码提交到本地仓库，进行远程推送前先进行获取最新解决冲突后再push</li><li>可以选择merge模式也可以rebase模式</li></ul><p>基本的开发模式：</p><ol><li>项目维护者推送到主仓库。</li><li>贡献者克隆此住仓库，做出修改。</li><li>贡献者将数据推送到自己的公开仓库。</li><li>贡献者给维护者发送邮件，请求拉取自己的更新。</li><li>维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。</li><li>维护者将合并后的修改推送到主仓库。</li></ol><p><img src="../images/gwf.jpg" alt="集中式工作流"></p><blockquote><p>进入公司后，需要问项目经理要一下公司的源码git仓库的地址，以及把自己的公钥给管理员，让他们帮你设置上权限，就可以clone项目了。</p></blockquote><p>本工作流比较简单，就不再概述。</p><h3 id="github的fork工作流"><a href="#github的fork工作流" class="headerlink" title="github的fork工作流"></a>github的fork工作流</h3><p>派生(Fork)项目,如果你想要参与某个项目，但是并没有推送权限，这时可以对这个项目进行“派生”。 派生的意思是 指，GitHub 将在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。</p><p>流程通常如下:</p><ol><li>从 master 分支中创建一个新分支</li><li>提交一些修改来改进项目</li><li>将这个分支推送到 GitHub 上</li><li>创建一个合并请求(pr)</li><li>讨论，根据实际情况继续修改</li><li>项目的拥有者合并或关闭你的合并请求</li></ol><p><img src="../images/fork.jpg" alt="github-fork工作流"></p><h3 id="项目分支管理模型"><a href="#项目分支管理模型" class="headerlink" title="项目分支管理模型"></a>项目分支管理模型</h3><p>一般一个完整的项目都会有很多分支，每个分支都有一些管理的规则。</p><p><img src="../images/branch_module.png" alt="设置ssh key"></p><h3 id="如何删除远程分支"><a href="#如何删除远程分支" class="headerlink" title="如何删除远程分支"></a>如何删除远程分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把一个空分支推送到远程的dev分支，也就是删除远程的dev分支</span></span><br><span class="line">$ git push origin :dev</span><br></pre></td></tr></table></figure><h2 id="git的钩子与自动化集成"><a href="#git的钩子与自动化集成" class="headerlink" title="git的钩子与自动化集成"></a>git的钩子与自动化集成</h2><p>Git 能在特定的重要动作发生时触发自定义脚本。这些特定的能注册执行脚本的事件就称为钩子。</p><h3 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h3><p>客户端钩子分为很多种。 下面把它们分为:提交工作流钩子、电子邮件工作流钩子和其它钩子。</p><h4 id="提交钩子"><a href="#提交钩子" class="headerlink" title="提交钩子"></a>提交钩子</h4><table><thead><tr><th>钩子名</th><th>作用</th></tr></thead><tbody><tr><td>pre-commit</td><td>钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试 运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no -verify 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致(运行类似 lint 的程序)、尾随空 白字符是否存在(自带的钩子就是这么做的)，或新方法的文档是否适当。</td></tr><tr><td>prepare-commit-msg</td><td>钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所 看到的默认信息。 该钩子接收一些选项:存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA- 1 校验。 它对一般的提交来说并没有什么用;然而对那些会自动产生默认信息的提交，如提交信息模板、合并提 交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</td></tr><tr><td>commit-msg</td><td>钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</td></tr><tr><td>post-commit</td><td>钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 git log -1 HEAD来获得最后一次的提交信息。该钩子一般用于通知之类的事情。</td></tr></tbody></table><p>例如： git提交的标签工具</p><p><a href="https://gitmoji.carloscuesta.me/">An emoji guide for your commit messages. 😜 </a></p><p>其他钩子请直接参考官网。</p><h3 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h3><p>服务器端的钩子可以帮我做很多事情，比如检测到提交好自动执行某些自动化部署的脚本，就能实现自动化的部署和提交。<br>所有服务器端的工作都将在你的 hooks 目录下的 update 脚本中完成。 update 脚本会为每一个提交的分支各<br>运行一次，它接受三个参数:</p><ul><li>被推送的引用的名字</li><li>推送前分支的修订版本(revision)</li><li>用户准备推送的修订版本(revision)</li></ul><p>例如：</p><p><img src="../images/hooks.jpg" alt="git钩子"></p><h2 id="git其他"><a href="#git其他" class="headerlink" title="git其他"></a>git其他</h2><h3 id="git命令别名"><a href="#git命令别名" class="headerlink" title="git命令别名"></a>git命令别名</h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git<br>config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>如果定义的别名想带上参数，那么需要对命令名加上引号。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.lf <span class="string">&#x27;log --graph --oneline&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用：</span></span><br><span class="line">$ git lf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br></pre></td></tr></table></figure><h3 id="git服务器端私有部署及权限管理"><a href="#git服务器端私有部署及权限管理" class="headerlink" title="git服务器端私有部署及权限管理"></a>git服务器端私有部署及权限管理</h3><p>请直接参考： <a href="https://www.jianshu.com/p/a0eb79fa5b8d">CentOS搭建Git服务器及权限管理</a></p><h3 id="搭建gitlab"><a href="#搭建gitlab" class="headerlink" title="搭建gitlab"></a>搭建gitlab</h3><p>直接参考：<a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab">4.8 服务器上的 Git - GitLab</a></p><h3 id="Git仓库迁移"><a href="#Git仓库迁移" class="headerlink" title="Git仓库迁移"></a>Git仓库迁移</h3><ol><li><p>从老仓库克隆一份裸板本库</p><p> git clone –bare git:<em>//oldgithub.com/username/oldproject.git</em> </p></li><li><p>在新的Git服务器上创建一个新仓库，比如 newproject</p></li><li><p>以镜像的方式推送代码到newproject</p><p>cd oldproject.git</p><p>git push –mirror <a href="mailto:&#x67;&#x69;&#116;&#x40;&#110;&#x65;&#x77;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#110;&#x65;&#x77;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>/username/newproject.git</p></li><li><p>删除本地代码</p><p>cd ..</p><p>rm -rf oldproject.git</p></li><li><p>切换远程仓库地址</p><p>git remote set-url roigin <a href="mailto:&#103;&#105;&#116;&#64;&#110;&#x65;&#119;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#116;&#64;&#110;&#x65;&#119;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>/username/newproject.git</p></li><li><p>此时本地代码就可以想往常一样commit、push了</p></li></ol><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>git stash命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git入门到高级教程&quot;&gt;&lt;a href=&quot;#Git入门到高级教程&quot; class=&quot;headerlink&quot; title=&quot;Git入门到高级教程&quot;&gt;&lt;/a&gt;Git入门到高级教程&lt;/h1&gt;&lt;h2 id=&quot;为什么要进行项目文件的版本管理&quot;&gt;&lt;a href=&quot;#为什么要进行</summary>
      
    
    
    
    <category term="JAVA" scheme="https://chinaxizozhi.chinaxiaozhi.github.io/category/JAVA/"/>
    
    
    <category term="git" scheme="https://chinaxizozhi.chinaxiaozhi.github.io/tag/git/"/>
    
  </entry>
  
</feed>
